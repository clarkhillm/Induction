#Induction
利用java的javascript引擎来工作。
目的：

	1. 降低难度
	2. 便于调试

问题：

性能。但这个问题并不确定。其实性能往往不是什么大的问题。因为我们每次处理的时候都需要去加载js文件，这样做的目的是保证可以及时的获取文件的变化，就如同所有的动态语言一样，但是这样不可避免的带来了IO的问题。不过也可能是我杞人忧天了，这样的性能损耗根本不需要计较。除非有大量同时的IO操作，当然，我觉得这是不可能的。

不过，除了加载文件，引擎也需要运转，这样的确是不合适的。应该分析文件的时间，或者MD5。MD5需要对文件做hash，这个其实也是有性能损耗的。比较时间吧。

javascript的模块  这是个问题，因为我们不可能什么都在一个JS文件里面搞定。需要在多个JS文件之间管理依赖关系。


详述：

我们有一堆纷乱的数据需要处理，在其中找到头绪。

数据来源是数据库，来自多张相互关联的表。java不善于处理这样的的数据。事实上，java根本就不适于做数据的处理，它缺乏工具，平添复杂性。


	* java复杂获取原始的数据（通过JDBC）
	* javascript负责对这些数据进行处理，把结果以JSON的形式返回给java。
	* java把这样的JSON返回给前台。

实现：

	* 目前实现是通过注入了大量的java对象来实现了一些功能，包括对数据的获取，也是通过注入srping的jdbcTemplate对象来完成的。所有的处理目前都在js这边。java那边基本上啥也不干。
	* 实现关注了不同jdk之间的js引擎兼容性的问题。



已知问题：不同版本的js引擎略有不同。需要考虑兼容性，目前已知的有：Nashorn引擎更贴近与java本身，直接引用java对象比较容易，但操作的方式更类似于java，不能用apply和call来调用java对象的方法，js对象没有问题。估计可以使用java的反射机制，这个问题可能以后会被解决。

设计目的
=======
设计的目的，本来其实很简单的。Java在数据处理方面其实并不是特别的方便，特别是对于需要大量数据变换的场景尤其不适。对于Java这样的编程语言来说，你如果想很好的处理数据，就需要首先为你的数据定义好类型。显然，这就是所谓PO的由来。当然对于这样的类型，我们其实也很不好做抽象，因为它就是数据，没有什么共性，可能就是离散的。

工作原理
=======

核心
-----
我们认定某一个JS是入口，该JS有一个execute方法。系统会为这个入口分配一个独立的JS引擎，这么做是处于健壮性的考虑，把JS引擎和任务绑定在一起，如果某一次任务失败了，导致引擎挂掉，那么不会影响其他的任务进行。而这个任务本身也很容易重新启动。其实它本质上就是为web而设计的，特别是RESTful的服务。每一次的请求其实都在一个独立的JS引擎中处理。但是引擎中的java元素是公用的，比如spring的jdbcTemplate对象，或者其他的java对象。系统其实会缓存这些JS引擎，这样不会每次请求都去加载引擎以及引擎相关的JS。目前其实还没有设计一个好的恢复机制，假如某个任务的JS引擎挂掉了，目前是不可能恢复的。需要注意的是这个execute方法，必须返回一个js的对象，否则系统会报错。。。

加载JS
------
JS对于java来说其实是当作配置文件被加载的。根据约定，我们把这些JS放到类路径下的js文件夹中。系统首先会加载Base.js以及一些全局的lib文件。Base.js是非常重要的，其中定义了命名空间，以及一些全局变量，依赖这些全局变量，js得以和java进行交互。目前js和java仅仅通过对象调用以及JSON字符串进行交互。被加载的js文件是不会被不断的加载的，系统会判断它的修改时间，只有最新的js会被重新的加载。

模块化
-----
JS变得有用，一个很大的原因就是其能够模块化。当然，JS本身是没有这个功能的，至少目前还没有。我们采用模拟命名空间+闭包的方式来实现模块化。模块之间的依赖关系，通过依赖注入来实现，这种方式有些类似Angularjs。在处理依赖的时候，处理了两种异常，一种是对自身的依赖，一种是循环依赖。